/** \file
 * Defines the types for the cQASM abstract syntax tree, based on the classes
 * from `cqasm::tree`.
 *
 * The `cqasm::ast::Node` base class derives from `cqasm::tree::Node`, adding
 * a few extra functions.
 *
 * The `visit()` function is used for the visitor pattern. It takes a
 * user-implemented object derived from `Visitor` (also defined here), which
 * has a member function for every kind of node in the tree. The `visit()`
 * function is simply defined to call the function in the `Visitor` class
 * implementation associated with the type of node. This decouples member
 * function implementations from the definition of the recursive structure.
 *
 * Two types of visitor base classes are defined, with different default
 * behavior.
 *
 *  - `Visitor` defaults to a fallback function for node types with no
 *    specific implementation. This function would usually just be no-op or
 *    throw an appropriate exception, based on what the visitor is supposed to
 *    do.
 *  - `RecursiveVisitor` defaults to traversing the tree depth-first for
 *    non-leaf nodes. Leaf nodes still default to a fallback function. This
 *    is useful when the goal is to flatten the recursive structure in some
 *    way.
 *
 * Besides the visitor pattern, you can also do Rust-like `if let` unpacking
 * using the `as_<type>` functions. They return an appropriately cast pointer
 * that is non-null if and only if the node is of the correct type. Making use
 * of the fact that null pointers cast to false and that we can declare
 * variables inside `if` statement expressions (just like we can in `for`
 * loops), we can do the following:
 *
 * ```c++
 * Node node = ...;
 * if (auto exp = node.as_string_literal()) {
 *     std::cout << exp->value << std::endl;
 * }
 * ```
 *
 * You can also emulate Rust-like case statements, either as a chain of
 * the above, or using the `type()` function. The latter returns a C enum
 * with all possible (leaf) types represented in it that you can switch over.
 * The unpacking/matching functionality of Rust is not automatic though, of
 * course. C++ can't do that.
 *
 * The equality and inequality operator are defined to do exact matching
 * except for annotation objects added to the nodes, which are ignored (not to
 * be confused with the Annotation AST nodes; these are an intrinsic part of
 * the grammar and are thus matched like anything else).
 *
 * `dump()` simply uses a predefined visistor class to produce a debug dump.
 * It can be passed any output stream, so you can dump to a string stream to
 * get the result as a string, if you want. There is also an overload for
 * the `<<` operator on streams, so you can use the `std::cout << node;`
 * notation as well.
 *
 * Most of the header/source code for the AST classes is generated by a
 * secondary C++ program at build-time, because defining all the classes
 * manually would be extremely tedious and error-prone.
 */

#pragma once

#include "cqasm-ast-gen.hpp"
#include <iostream>
#include <sstream>

namespace cqasm {
namespace ast {

/**
 * Special/temporary string builder node, used to build strings from fragments
 * and escape sequences while parsing. This is abstracted out of the AST; it
 * should never appear after parsing completes.
 */
class StringBuilder : public cqasm::tree::Base {
public:
    std::ostringstream stream;

    /**
     * Pushes a string fragment into the string.
     */
    void push_string(const std::string &str);

    /**
     * Pushes an escape sequence into the string.
     */
    void push_escape(const std::string &escape);

};

} // namespace ast
} // namespace cqasm
